package generator

import (
	"context"
	"fmt"
	"github.com/mach-composer/mach-composer-cli/internal/config"
	"github.com/mach-composer/mach-composer-cli/internal/dependency"
	"github.com/mach-composer/mach-composer-cli/internal/state"
	"github.com/mach-composer/mach-composer-cli/internal/utils"
	"github.com/rs/zerolog/log"
	"strings"
)

var componentWriter WriterFunc = func(ctx context.Context, cfg *config.MachConfig, g *dependency.Graph,
	options *GenerateOptions) error {
	for _, n := range g.Vertices() {
		sr, err := state.NewRenderer(
			state.Type(cfg.Global.TerraformStateProvider),
			n.Identifier(),
			cfg.Global.TerraformConfig.RemoteState,
		)

		err = cfg.StateRepository.Add(sr.Key(), sr)
		if err != nil {
			return err
		}
	}

	for _, n := range g.Vertices() {
		outPath := fmt.Sprintf("%s/%s", options.OutputPath, n.Path())

		switch n.Type() {
		case dependency.ProjectType:
			log.Debug().Msgf("No files to generate for project %s", n.Path())
			break
		case dependency.SiteType:
			log.Debug().Msgf("No files to generate for site %s", n.Path())
			break
		case dependency.SiteComponentType:
			s, err := cfg.Sites.Get(n.Parent().Identifier())
			if err != nil {
				return err
			}

			sc, err := s.Components.Get(n.Identifier())
			if err != nil {
				return err
			}

			if err = writeSecrets(cfg, s.Identifier, outPath); err != nil {
				return err
			}

			log.Info().Msgf("Writing site component %s", n.Path())
			body, err := renderSiteComponent(ctx, cfg, s, sc)
			if err != nil {
				return err
			}

			err = writeContent(cfg.ConfigHash, outPath, body)
			if err != nil {
				return err
			}
			break
		default:
			return fmt.Errorf("unknown node type %T", n)
		}

	}

	return nil
}

type componentContext struct {
	ComponentName       string
	SiteName            string
	Environment         string
	Source              string
	PluginResources     []string
	PluginProviders     []string
	PluginDependsOn     []string
	PluginVariables     []string
	ComponentVariables  string
	ComponentSecrets    string
	ComponentVersion    string
	HasCloudIntegration bool
}

func renderSiteComponent(ctx context.Context, cfg *config.MachConfig, site *config.SiteConfig, siteComponent *config.SiteComponentConfig) (string, error) {
	result := []string{
		"# This file is auto-generated by MACH composer",
		fmt.Sprintf("# SiteComponent: %s", siteComponent.Name),
	}

	// Render the terraform config
	val, err := renderSiteComponentTerraformConfig(cfg, site, siteComponent)
	if err != nil {
		return "", fmt.Errorf("renderSiteTerraformConfig: %w", err)
	}
	result = append(result, val)

	// Render all the file sources
	val, err = renderFileSources(cfg, site)
	if err != nil {
		return "", fmt.Errorf("failed to render file sources: %w", err)
	}
	result = append(result, val)

	// Render all the resources required by the site siteComponent
	val, err = renderSiteComponentResources(cfg, site, siteComponent)
	if err != nil {
		return "", fmt.Errorf("failed to render resources: %w", err)
	}
	result = append(result, val)

	// Render data links to other deployments
	val, err = renderRemoteSources(cfg, siteComponent)
	if err != nil {
		return "", fmt.Errorf("failed to render remote sources: %w", err)
	}
	result = append(result, val)

	// Render the siteComponent
	val, err = renderComponent(ctx, cfg, site, siteComponent)
	if err != nil {
		return "", fmt.Errorf("failed to render remote sources: %w", err)
	}
	result = append(result, val)

	content := strings.Join(result, "\n")

	return content, nil
}

func renderSiteComponentTerraformConfig(cfg *config.MachConfig, site *config.SiteConfig,
	siteComponent *config.SiteComponentConfig) (string, error) {
	var providers []string
	for _, plugin := range cfg.Plugins.Names(siteComponent.Definition.Integrations...) {
		content, err := plugin.RenderTerraformProviders(site.Identifier)
		if err != nil {
			return "", fmt.Errorf("plugin %s failed to render providers: %w", plugin.Name, err)
		}
		if content != "" {
			providers = append(providers, content)
		}
	}

	if !cfg.StateRepository.Has(site.Identifier) {
		return "", fmt.Errorf("state repository does not have a backend for site %s", site.Identifier)
	}
	backendConfig, err := cfg.StateRepository.Get(site.Identifier).Backend()
	if err != nil {
		return "", err
	}

	tpl, err := templates.ReadFile("templates/terraform.tmpl")
	if err != nil {
		return "", err
	}

	templateContext := struct {
		Providers     []string
		BackendConfig string
		IncludeSOPS   bool
	}{
		Providers:     providers,
		BackendConfig: backendConfig,
		IncludeSOPS:   cfg.Variables.HasEncrypted(site.Identifier),
	}
	return utils.RenderGoTemplate(string(tpl), templateContext)
}

func renderSiteComponentResources(cfg *config.MachConfig, site *config.SiteConfig, siteComponent *config.SiteComponentConfig) (string, error) {
	var resources []string
	for _, plugin := range cfg.Plugins.Names(siteComponent.Definition.Integrations...) {
		content, err := plugin.RenderTerraformResources(site.Identifier)
		if err != nil {
			return "", fmt.Errorf("plugin %s failed to render resources: %w", plugin.Name, err)
		}

		if content != "" {
			resources = append(resources, content)
		}
	}

	tpl, err := templates.ReadFile("templates/resources.tmpl")
	if err != nil {
		return "", err
	}

	return utils.RenderGoTemplate(string(tpl), resources)
}

// renderComponent uses templates/component.tf to generate a terraform snippet for each component
func renderComponent(_ context.Context, cfg *config.MachConfig, site *config.SiteConfig, siteComponent *config.SiteComponentConfig) (string, error) {
	tc := componentContext{
		ComponentName:    siteComponent.Name,
		ComponentVersion: siteComponent.Definition.Version,
		SiteName:         site.Identifier,
		Environment:      cfg.Global.Environment,
		Source:           siteComponent.Definition.Source,
		PluginResources:  []string{},
		PluginVariables:  []string{},
		PluginDependsOn:  []string{},
		PluginProviders:  []string{},
	}

	for _, plugin := range cfg.Plugins.Names(siteComponent.Definition.Integrations...) {
		plugin, err := cfg.Plugins.Get(plugin.Name)
		if err != nil {
			return "", err
		}

		cr, err := plugin.RenderTerraformComponent(site.Identifier, siteComponent.Name)
		if err != nil {
			return "", fmt.Errorf("plugin %s failed to render siteComponent: %w", plugin.Name, err)
		}

		if cr == nil {
			continue
		}

		tc.PluginResources = append(tc.PluginResources, cr.Resources)
		tc.PluginVariables = append(tc.PluginVariables, cr.Variables)
		tc.PluginProviders = append(tc.PluginProviders, cr.Providers...)
		tc.PluginDependsOn = append(tc.PluginDependsOn, cr.DependsOn...)
	}

	tpl, err := templates.ReadFile("templates/site_component.tmpl")
	if err != nil {
		return "", err
	}

	if siteComponent.HasCloudIntegration(&cfg.Global) {
		tc.HasCloudIntegration = true
		tc.ComponentVariables = "variables = {}"
		tc.ComponentSecrets = "secrets = {}"
	}

	if len(siteComponent.Variables) > 0 {
		val, err := serializeToHCL("variables", siteComponent.Variables)
		if err != nil {
			return "", err
		}
		tc.ComponentVariables = val
	}
	if len(siteComponent.Secrets) > 0 {
		val, err := serializeToHCL("secrets", siteComponent.Secrets)
		if err != nil {
			return "", err
		}
		tc.ComponentSecrets = val
	}

	if siteComponent.Definition.IsGitSource() {
		// When using Git, we will automatically add a reference to the string
		// so that the given version is used when fetching the module itself
		// from Git as well
		tc.Source += fmt.Sprintf("?ref=%s", siteComponent.Definition.Version)
	}

	val, err := utils.RenderGoTemplate(string(tpl), tc)
	if err != nil {
		return "", fmt.Errorf("renderSiteTerraformConfig: %w", err)
	}
	return val, nil
}

func renderRemoteSources(cfg *config.MachConfig, component *config.SiteComponentConfig) (string, error) {
	parents := component.Variables.ListComponents()
	parents = append(parents, component.Secrets.ListComponents()...)

	var result []string

	for _, parent := range parents {
		if !cfg.StateRepository.Has(parent) {
			return "", fmt.Errorf("missing remoteState for %s", parent)
		}

		remoteState, err := cfg.StateRepository.Get(parent).RemoteState()
		if err != nil {
			return "", err
		}

		result = append(result, remoteState)
	}

	return strings.Join(result, "\n"), nil
}
